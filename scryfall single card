--Script created by Budster024 
--Jan 2026
--Scryfall Patcher 1.0
--single card search
--
-- Added:
-- ✔ normal/small ONLY (no large/png)
-- ✔ DFC support using States (right-click -> States)
-- ✔ lock + safety timeout
-- ✔ 5s cooldown

local SCRY_BASE = "https://api.scryfall.com"
local BACK_URL  = "https://steamusercontent-a.akamaihd.net/ugc/1647720103762682461/35EF6E87970E2A5D6581E7D96A99F8A575B7A15F/" -- change to your back URL

local MIN_DELAY = 0.30
local MAX_RETRY = 3

local BTN_Y       = 0.35
local STACK_POS   = { x = 0, z = -5 }
local BASE_LIFT   = 3.0
local CARD_LIFT   = 0.20
local _stackIndex = 0
local _deckIdCounter = 1
local _nextTime   = 0

local searchText  = ""

-- DFC behavior
local USE_STATES_FOR_DFC = true  -- true = state swap (recommended). false = single-face only.

-- Safeguards
local COOLDOWN_SECONDS       = 5
local SAFETY_TIMEOUT_SECONDS = 30
local _busy = false
local _cooldownUntil = 0
local _safetyEndsAt = 0

local function scryHeaders()
  return {
    ["User-Agent"] = "TTS-RandomSpawner/1.0 (Tabletop Simulator)",
    ["Accept"]     = "application/json;q=0.9,*/*;q=0.8",
  }
end

local function schedule(fn, delay)
  Wait.time(fn, math.max(0, delay or 0))
end

local function urlEncode(str)
  if not str then return "" end
  str = tostring(str)
  str = str:gsub("\n", "\r\n")
  str = str:gsub("([^%w %-%_%.%~])", function(c)
    return string.format("%%%02X", string.byte(c))
  end)
  str = str:gsub(" ", "%%20")
  return str
end

local function forceUnlockIfTimedOut()
  local now = os.time()
  if _busy and _safetyEndsAt ~= 0 and now >= _safetyEndsAt then
    _busy = false
    _safetyEndsAt = 0
    print("Search spawner safety timeout reached. Unlocking.")
  end
end

local function queueRequest(url, cb, attempt)
  attempt = attempt or 1

  local now = os.clock()
  _nextTime = math.max(_nextTime, now) + MIN_DELAY
  local delay = math.max(0, _nextTime - now)

  schedule(function()
    WebRequest.custom(url, "GET", true, nil, scryHeaders(), function(req)
      if req.is_error then
        if attempt < MAX_RETRY then
          schedule(function() queueRequest(url, cb, attempt + 1) end, 0.6)
        else
          cb(false, "WebRequest error: " .. tostring(req.error), req)
        end
        return
      end

      local code = tonumber(req.response_code) or 0

      if code == 429 then
        if attempt < MAX_RETRY then
          local backoff = 1.5 * attempt
          _nextTime = os.clock() + backoff
          schedule(function() queueRequest(url, cb, attempt + 1) end, backoff)
        else
          cb(false, "HTTP 429 Too Many Requests (max retries hit)", req)
        end
        return
      end

      if code >= 500 and code <= 599 then
        if attempt < MAX_RETRY then
          local backoff = 0.75 * attempt
          schedule(function() queueRequest(url, cb, attempt + 1) end, backoff)
        else
          cb(false, "HTTP " .. tostring(code) .. " (max retries hit)", req)
        end
        return
      end

      if code ~= 200 then
        cb(false, "HTTP " .. tostring(code) .. (req.text and (": " .. req.text) or ""), req)
        return
      end

      cb(true, req.text, req)
    end)
  end, delay)
end

-- normal preferred, small fallback; NO large/png
local function pickFaceUrlFromImageUris(iu)
  if not iu then return nil end
  return iu.normal or iu.small
end

local function pickFaceUrl(data)
  if data.image_uris then
    return pickFaceUrlFromImageUris(data.image_uris)
  end
  if data.card_faces and data.card_faces[1] and data.card_faces[1].image_uris then
    return pickFaceUrlFromImageUris(data.card_faces[1].image_uris)
  end
  return nil
end

local function pickFaceUrlAtIndex(data, idx)
  if not data or not data.card_faces or not data.card_faces[idx] then return nil end
  return pickFaceUrlFromImageUris(data.card_faces[idx].image_uris)
end

local function isDFC(data)
  return (data and data.card_faces and type(data.card_faces) == "table" and #data.card_faces >= 2)
end

-- dash fix: — / – / ?  -> --
local function dashFix(s)
  if not s or s == "" then return "" end
  s = tostring(s)
  s = s:gsub("—", "--")
  s = s:gsub("–", "--")
  s = s:gsub("%?", "--")
  return s
end

local function buildNickname(data)
  local function safe(v) return (v == nil) and "" or tostring(v) end

  local cmc = safe(data.cmc)
  local typeLine = dashFix(safe(data.type_line))
  local name = safe(data.name)

  if data.card_faces and data.card_faces[1] then
    local f = data.card_faces[1]
    local fName = safe(f.name) ~= "" and safe(f.name) or name
    local fTypeRaw = safe(f.type_line)
    local fType = dashFix(fTypeRaw) ~= "" and dashFix(fTypeRaw) or typeLine

    if cmc ~= "" then
      return fName .. "\n" .. fType .. " " .. cmc .. "CMC"
    else
      return fName .. "\n" .. fType
    end
  end

  if cmc ~= "" then
    return name .. "\n" .. typeLine .. " " .. cmc .. "CMC"
  end
  return name .. "\n" .. typeLine
end

local function buildDescription(data)
  local function ptLine(obj)
    if obj and obj.power and obj.toughness then
      return "\n[b]" .. tostring(obj.power) .. "/" .. tostring(obj.toughness) .. "[/b]"
    elseif obj and obj.loyalty then
      return "\n[b]" .. tostring(obj.loyalty) .. "[/b]"
    end
    return ""
  end

  if data.card_faces and (not data.oracle_text) then
    local out = {}
    for _, f in ipairs(data.card_faces) do
      local ot = f.oracle_text or ""
      table.insert(out, ot .. ptLine(f))
    end
    return table.concat(out, "\n\n---\n\n")
  end

  return (data.oracle_text or "") .. ptLine(data)
end

local function getNextStackWorldPos()
  local base = self.getPosition()
  _stackIndex = _stackIndex + 1
  return {
    x = base.x + STACK_POS.x,
    y = base.y + BASE_LIFT + (_stackIndex * CARD_LIFT),
    z = base.z + STACK_POS.z
  }
end

-- Build a CardCustom JSON table for a given deckId and faceURL, optionally overriding name/desc
local function makeCardCustom(deckId, faceURL, pos, nickname, description)
  return {
    Name = "CardCustom",
    Transform = {
      posX = pos.x, posY = pos.y, posZ = pos.z,
      rotX = 0, rotY = 180, rotZ = 0,
      scaleX = 1, scaleY = 1, scaleZ = 1
    },
    Nickname = nickname or "",
    Description = description or "",
    CardID = deckId * 100,
    CustomDeck = {
      [tostring(deckId)] = {
        FaceURL = faceURL,
        BackURL = BACK_URL,
        NumWidth = 1,
        NumHeight = 1,
        BackIsHidden = true
      }
    }
  }
end

local function spawnCardFromJson(jsonText)
  local data = JSON.decode(jsonText)
  if not data then
    print("Scryfall: invalid JSON response.")
    return
  end
  if data.object == "error" then
    print("Scryfall error: " .. tostring(data.details or "Unknown error"))
    return
  end
  if data.object ~= "card" then
    print("Scryfall response was not a card object.")
    return
  end

  local deckId = _deckIdCounter
  _deckIdCounter = _deckIdCounter + 1

  local pos = getNextStackWorldPos()
  local nickname = buildNickname(data)
  local description = buildDescription(data)

  -- Base face (single-face or face 1 of DFC)
  local face1 = pickFaceUrl(data)
  if not face1 then
    print("No image URL found for: " .. tostring(data.name or "unknown"))
    return
  end

  local cardObj = makeCardCustom(deckId, face1, pos, nickname, description)

  -- DFC support via States: State 2 is face 2
  if USE_STATES_FOR_DFC and isDFC(data) then
    local face2 = pickFaceUrlAtIndex(data, 2)
    if face2 then
      -- Build state 2 card object. Use same deckId & CardID for simplicity.
      local state2 = makeCardCustom(deckId, face2, pos, nickname, description)
      cardObj.States = {
        ["2"] = state2
      }
    else
      -- DFC but no image for face2 (rare, but don't crash)
      print("DFC detected but face 2 image missing for: " .. tostring(data.name or "unknown"))
    end
  end

  spawnObjectJSON({ json = JSON.encode(cardObj) })
end

local function trimmed(s)
  s = tostring(s or "")
  return (s:gsub("^%s+", ""):gsub("%s+$", ""))
end

-- IMPORTANT: Make these non-local & also put them in _G for TTS callbacks
function onSearchInput(obj, playerColor, input, stillEditing)
  searchText = tostring(input or "")
end
_G["onSearchInput"] = onSearchInput

function spawnSearchedCard()
  forceUnlockIfTimedOut()

  local now = os.time()
  if _busy then return end
  if now < _cooldownUntil then
    local left = _cooldownUntil - now
    print("Cooldown: " .. tostring(left) .. "s")
    return
  end

  local name = trimmed(searchText)
  if name == "" then
    print("Type a card name first.")
    return
  end

  _busy = true
  _safetyEndsAt = now + SAFETY_TIMEOUT_SECONDS
  _cooldownUntil = now + COOLDOWN_SECONDS

  local url = SCRY_BASE .. "/cards/named?fuzzy=" .. urlEncode(name)

  queueRequest(url, function(ok, body)
    if ok then
      spawnCardFromJson(body)
    else
      print("Card fetch failed: " .. tostring(body))
    end

    _busy = false
    _safetyEndsAt = 0
  end)
end
_G["spawnSearchedCard"] = spawnSearchedCard

function onLoad()
  math.randomseed(os.time())

  -- 3D input field
  self.createInput({
    input_function = "onSearchInput",
    function_owner = self,
    label          = "Search card name...",
    alignment      = 3,
    position       = {0, BTN_Y, 0.9},
    rotation       = {0, 180, 0},
    width          = 2600,
    height         = 350,
    font_size      = 180,
    validation     = 1
  })

  -- Spawn button
  self.createButton({
    click_function = "spawnSearchedCard",
    function_owner = self,
    label          = "Spawn Card",
    position       = {0, BTN_Y, 0},
    rotation       = {0, 180, 0},
    width          = 1700,
    height         = 380,
    font_size      = 150,
    color          = Color.Grey
  })
end
