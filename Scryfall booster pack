---------------------------------------------------------------------------
--Deck Spawner
--Script created by Budster024
--Jan 2026
--Scryfall Patcher 1.0
--
-- Scryfall -> Spawn 14 Random (Paper, Non-Funny) -> ONE STACK PILE
-- DIRECT Scryfall API
-- ✔ normal / small images ONLY (NO large/png)
-- ✔ DFC support using States (right-click -> States)
-- ✔ throttle + 429 backoff + retries
-- ✔ 60s cooldown
-- ✔ spawn lock + safety timeout
-- ✔ CMC + Type Line added to Nickname (NO other behavior changed)
---------------------------------------------------------------------------

local SCRY_BASE = "https://api.scryfall.com"
local BACK_URL  = "https://steamusercontent-a.akamaihd.net/ugc/1647720103762682461/35EF6E87970E2A5D6581E7D96A99F8A575B7A15F/"

-- DFC behavior
local USE_STATES_FOR_DFC = true -- true = attach State 2 for face 2 on DFC cards

-- Rate limiting
local MIN_DELAY = 0.35
local MAX_RETRY = 3

-- Pack config + safety cap
local PACK_SIZE = 14
local MAX_PACK_SIZE = 30

-- Cooldown + lock/timeout safeguards
local COOLDOWN_SECONDS       = 15
local SPAWN_TIMEOUT_SECONDS  = 90
local _cooldownUntil         = 0
local _isSpawning            = false
local _spawnEndsAt           = 0

-- Button / spawn layout
local BTN_Y       = 0.35
local STACK_POS   = { x = 0, z = -5 }
local BASE_LIFT   = 7.0
local CARD_LIFT   = 0.20

-- Internal state
local _stackIndex     = 0
local _deckIdCounter  = 1
local _nextTime       = 0

---------------------------------------------------------------------------
-- Headers (API compliant)
---------------------------------------------------------------------------
local function scryHeaders()
  return {
    ["User-Agent"] = "TTS-RandomSpawner/1.2 (Tabletop Simulator)",
    ["Accept"]     = "application/json;q=0.9,*/*;q=0.8",
  }
end

---------------------------------------------------------------------------
-- Utilities
---------------------------------------------------------------------------
local function schedule(fn, delay)
  Wait.time(fn, math.max(0, delay or 0))
end

local function urlEncode(str)
  if not str then return "" end
  str = tostring(str)
  str = str:gsub("\n", "\r\n")
  str = str:gsub("([^%w %-%_%.%~])", function(c)
    return string.format("%%%02X", string.byte(c))
  end)
  return str:gsub(" ", "%%20")
end

local function forceUnlockIfTimedOut()
  local now = os.time()
  if _isSpawning and now >= _spawnEndsAt then
    _isSpawning = false
    print("Spawner safety timeout reached. Unlocking.")
  end
end

---------------------------------------------------------------------------
-- Request queue w/ throttle + backoff
---------------------------------------------------------------------------
local function queueRequest(url, cb, attempt)
  attempt = attempt or 1

  local now = os.clock()
  _nextTime = math.max(_nextTime, now) + MIN_DELAY
  local delay = math.max(0, _nextTime - now)

  schedule(function()
    WebRequest.custom(url, "GET", true, nil, scryHeaders(), function(req)
      if req.is_error then
        if attempt < MAX_RETRY then
          schedule(function()
            queueRequest(url, cb, attempt + 1)
          end, 0.6)
        else
          cb(false, req.error or "WebRequest error")
        end
        return
      end

      local code = tonumber(req.response_code) or 0

      if code == 429 and attempt < MAX_RETRY then
        local backoff = 1.5 * attempt
        _nextTime = os.clock() + backoff
        schedule(function()
          queueRequest(url, cb, attempt + 1)
        end, backoff)
        return
      end

      if code >= 500 and code <= 599 and attempt < MAX_RETRY then
        local backoff = 0.75 * attempt
        schedule(function()
          queueRequest(url, cb, attempt + 1)
        end, backoff)
        return
      end

      if code ~= 200 then
        cb(false, "HTTP " .. code)
        return
      end

      cb(true, req.text)
    end)
  end, delay)
end

---------------------------------------------------------------------------
-- Image selection (NORMAL / SMALL ONLY)
---------------------------------------------------------------------------
local function pickFaceUrlFromImageUris(iu)
  if not iu then return nil end
  return iu.normal or iu.small
end

local function pickFaceUrl(data)
  if data.image_uris then
    return pickFaceUrlFromImageUris(data.image_uris)
  end

  if data.card_faces and data.card_faces[1] and data.card_faces[1].image_uris then
    return pickFaceUrlFromImageUris(data.card_faces[1].image_uris)
  end

  return nil
end

local function pickFaceUrlAtIndex(data, idx)
  if not data or not data.card_faces or not data.card_faces[idx] then return nil end
  return pickFaceUrlFromImageUris(data.card_faces[idx].image_uris)
end

local function isDFC(data)
  return (data and data.card_faces and type(data.card_faces) == "table" and #data.card_faces >= 2)
end

---------------------------------------------------------------------------
-- Card text
---------------------------------------------------------------------------
-- dash fix: — / – / ? -> --
local function dashFix(s)
  if not s or s == "" then return "" end
  s = tostring(s)
  s = s:gsub("—", "--")
  s = s:gsub("–", "--")
  s = s:gsub("%?", "--")
  return s
end

-- Nickname format:
-- Name
-- Type Line -- Subtype <CMC>CMC
local function buildNickname(data)
  local function safe(v) return (v == nil) and "" or tostring(v) end

  local cmc = safe(data.cmc)
  local typeLine = dashFix(safe(data.type_line))
  local name = safe(data.name)

  if data.card_faces and data.card_faces[1] then
    local f = data.card_faces[1]
    local fName = safe(f.name) ~= "" and safe(f.name) or name
    local fTypeRaw = safe(f.type_line)
    local fType = dashFix(fTypeRaw) ~= "" and dashFix(fTypeRaw) or typeLine

    if cmc ~= "" then
      return fName .. "\n" .. fType .. " " .. cmc .. "CMC"
    else
      return fName .. "\n" .. fType
    end
  end

  if cmc ~= "" then
    return name .. "\n" .. typeLine .. " " .. cmc .. "CMC"
  end
  return name .. "\n" .. typeLine
end

local function buildDescription(data)
  if data.card_faces and not data.oracle_text then
    local out = {}
    for i, f in ipairs(data.card_faces) do
      table.insert(out, (f.name or "") .. "\n" .. (f.oracle_text or ""))
    end
    return table.concat(out, "\n\n---\n\n")
  end
  return data.oracle_text or ""
end

---------------------------------------------------------------------------
-- Spawn helpers
---------------------------------------------------------------------------
local function getNextStackWorldPos()
  local base = self.getPosition()
  _stackIndex = _stackIndex + 1
  return {
    x = base.x + STACK_POS.x,
    y = base.y + BASE_LIFT + (_stackIndex * CARD_LIFT),
    z = base.z + STACK_POS.z
  }
end

local function makeCardCustom(deckId, faceURL, pos, nickname, description)
  return {
    Name = "CardCustom",
    Transform = {
      posX = pos.x, posY = pos.y, posZ = pos.z,
      rotX = 0, rotY = 180, rotZ = 0,
      scaleX = 1, scaleY = 1, scaleZ = 1
    },
    Nickname = nickname or "",
    Description = description or "",
    CardID = deckId * 100,
    CustomDeck = {
      [tostring(deckId)] = {
        FaceURL = faceURL,
        BackURL = BACK_URL,
        NumWidth = 1,
        NumHeight = 1,
        BackIsHidden = true
      }
    }
  }
end

local function spawnCardFromJson(jsonText)
  local data = JSON.decode(jsonText)
  if not data then return end
  if data.object == "error" then return end
  if data.object ~= "card" then return end

  local face1 = pickFaceUrl(data)
  if not face1 then return end

  local deckId = _deckIdCounter
  _deckIdCounter = _deckIdCounter + 1

  local pos = getNextStackWorldPos()
  local nickname = buildNickname(data)
  local description = buildDescription(data)

  local cardObj = makeCardCustom(deckId, face1, pos, nickname, description)

  -- DFC -> attach State 2 with face 2 art
  if USE_STATES_FOR_DFC and isDFC(data) then
    local face2 = pickFaceUrlAtIndex(data, 2)
    if face2 then
      local state2 = makeCardCustom(deckId, face2, pos, nickname, description)
      cardObj.States = { ["2"] = state2 }
    end
  end

  spawnObjectJSON({ json = JSON.encode(cardObj) })
end

---------------------------------------------------------------------------
-- Random card fetch
---------------------------------------------------------------------------
local function buildRandomQuery()
  return "game:paper -is:digital -is:funny"
end

local function fetchAndSpawnOneRandom()
  local url = SCRY_BASE .. "/cards/random?q=" .. urlEncode(buildRandomQuery())
  queueRequest(url, function(ok, body)
    if ok then
      spawnCardFromJson(body)
    end
  end)
end

---------------------------------------------------------------------------
-- Button action (cooldown + lock + timeout)
---------------------------------------------------------------------------
function spawn14RandomCards()
  local now = os.time()

  forceUnlockIfTimedOut()

  if _isSpawning then
    print("Spawner already running.")
    return
  end

  if now < _cooldownUntil then
    print("Spawner on cooldown (" .. (_cooldownUntil - now) .. "s remaining)")
    return
  end

  if PACK_SIZE > MAX_PACK_SIZE then
    print("Safety cap hit: PACK_SIZE too high.")
    return
  end

  _isSpawning = true
  _spawnEndsAt = now + SPAWN_TIMEOUT_SECONDS
  _cooldownUntil = now + COOLDOWN_SECONDS

  _stackIndex = 0

  for i = 1, PACK_SIZE do
    schedule(fetchAndSpawnOneRandom, (i - 1) * 0.01)
  end

  schedule(function()
    _isSpawning = false
  end, (PACK_SIZE * MIN_DELAY) + 2)
end
_G["spawn14RandomCards"] = spawn14RandomCards

---------------------------------------------------------------------------
-- Init
---------------------------------------------------------------------------
function onLoad()
  math.randomseed(os.time())

  self.createButton({
    click_function = "spawn14RandomCards",
    function_owner = self,
    label          = "Spawn Booster Pack",
    position       = {0, BTN_Y, 0},
    rotation       = {0, 180, 0},
    width          = 1900,
    height         = 420,
    font_size      = 150,
    color          = Color.Grey
  })
end
