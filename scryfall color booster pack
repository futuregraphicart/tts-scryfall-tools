---------------------------------------------------------------------------
--Script created by Budster024 
--Jan 2026
--Scryfall Patcher 1.0
--single card search
--
-- Scryfall -> 5 Color Identity Toggles -> Spawn 14 Random Cards (ONE STACK)
-- Uses DIRECT Scryfall API with THROTTLE + 429 BACKOFF + RETRIES
--
-- Notes:
-- - Cards are: paper, non-digital, non-funny
-- - If NO colors are selected, it spawns from ALL colors (no id: filter).
-- - All spawned cards stack into ONE pile (same X/Z, rising Y).
--
-- Added:
-- ✔ normal/small ONLY (no large/png)
-- ✔ DFC support using States (right-click -> States)
-- ✔ spawn lock + safety timeout (no runaway / no stuck busy)
---------------------------------------------------------------------------

local SCRY_BASE = "https://api.scryfall.com"
local BACK_URL  = "https://steamusercontent-a.akamaihd.net/ugc/1647720103762682461/35EF6E87970E2A5D6581E7D96A99F8A575B7A15F/" -- change to your back URL

-- Throttle (buffer) between requests to reduce rate-limit risk
local MIN_DELAY = 0.35
local MAX_RETRY = 3

-- UI / stacking
local BTN_Y     = 0.35
local BTN_ROT   = {0, 180, 0}

local STACK_POS = { x = 0, z = -5 }

-- Spawn higher so cards don't appear under the table
local BASE_LIFT = 7.0
local CARD_LIFT = 0.20

-- Queue / stack state
local _stackIndex     = 0
local _deckIdCounter  = 1
local _nextTime       = 0
local _busy           = false

-- Safeguards
local SPAWN_TIMEOUT_SECONDS = 5
local _spawnEndsAt = 0

-- DFC behavior
local USE_STATES_FOR_DFC = true -- true = attach State 2 for face 2

-- Color identity state
local White = false
local Blue  = false
local Black = false
local Red   = false
local Green = false

---------------------------------------------------------------------------
-- Headers
---------------------------------------------------------------------------
local function scryHeaders()
  return {
    ["User-Agent"] = "TTS-RandomSpawner/1.0 (Tabletop Simulator)",
    ["Accept"]     = "application/json;q=0.9,*/*;q=0.8",
  }
end

local function schedule(fn, delay)
  Wait.time(fn, math.max(0, delay or 0))
end

local function urlEncode(str)
  if not str then return "" end
  str = tostring(str)
  str = str:gsub("\n", "\r\n")
  str = str:gsub("([^%w %-%_%.%~])", function(c)
    return string.format("%%%02X", string.byte(c))
  end)
  str = str:gsub(" ", "%%20")
  return str
end

-- Safeguard: unlock if stuck
local function forceUnlockIfTimedOut()
  local now = os.time()
  if _busy and _spawnEndsAt ~= 0 and now >= _spawnEndsAt then
    _busy = false
    _spawnEndsAt = 0
    print("Color booster safety timeout reached. Unlocking.")
  end
end

---------------------------------------------------------------------------
-- Timed request queue + 429 backoff + retries
---------------------------------------------------------------------------
local function queueRequest(url, cb, attempt)
  attempt = attempt or 1

  local now = os.clock()
  _nextTime = math.max(_nextTime, now) + MIN_DELAY
  local delay = math.max(0, _nextTime - now)

  schedule(function()
    WebRequest.custom(url, "GET", true, nil, scryHeaders(), function(req)
      if req.is_error then
        if attempt < MAX_RETRY then
          schedule(function() queueRequest(url, cb, attempt + 1) end, 0.6)
        else
          cb(false, "WebRequest error: " .. tostring(req.error), req)
        end
        return
      end

      local code = tonumber(req.response_code) or 0

      if code == 429 then
        if attempt < MAX_RETRY then
          local backoff = 1.5 * attempt
          _nextTime = os.clock() + backoff
          schedule(function() queueRequest(url, cb, attempt + 1) end, backoff)
        else
          cb(false, "HTTP 429 Too Many Requests (max retries hit)", req)
        end
        return
      end

      if code >= 500 and code <= 599 then
        if attempt < MAX_RETRY then
          local backoff = 0.75 * attempt
          schedule(function() queueRequest(url, cb, attempt + 1) end, backoff)
        else
          cb(false, "HTTP " .. tostring(code) .. " (max retries hit)", req)
        end
        return
      end

      if code ~= 200 then
        cb(false, "HTTP " .. tostring(code) .. (req.text and (": " .. req.text) or ""), req)
        return
      end

      cb(true, req.text, req)
    end)
  end, delay)
end

---------------------------------------------------------------------------
-- Card helpers
---------------------------------------------------------------------------
local function pickFaceUrlFromImageUris(iu)
  if not iu then return nil end
  return iu.normal or iu.small
end

local function pickFaceUrl(data)
  if data.image_uris then
    return pickFaceUrlFromImageUris(data.image_uris)
  end
  if data.card_faces and data.card_faces[1] and data.card_faces[1].image_uris then
    return pickFaceUrlFromImageUris(data.card_faces[1].image_uris)
  end
  return nil
end

local function pickFaceUrlAtIndex(data, idx)
  if not data or not data.card_faces or not data.card_faces[idx] then return nil end
  return pickFaceUrlFromImageUris(data.card_faces[idx].image_uris)
end

local function isDFC(data)
  return (data and data.card_faces and type(data.card_faces) == "table" and #data.card_faces >= 2)
end

-- dash fix: — / – / ?  -> --
local function dashFix(s)
  if not s or s == "" then return "" end
  s = tostring(s)
  s = s:gsub("—", "--")
  s = s:gsub("–", "--")
  s = s:gsub("%?", "--")
  return s
end

-- Nickname format:
-- Name
-- Type Line -- Subtype <CMC>CMC
local function buildNickname(data)
  local function safe(v) return (v == nil) and "" or tostring(v) end

  local cmc = safe(data.cmc)
  local typeLine = dashFix(safe(data.type_line))
  local name = safe(data.name)

  if data.card_faces and data.card_faces[1] then
    local f = data.card_faces[1]
    local fName = safe(f.name) ~= "" and safe(f.name) or name
    local fTypeRaw = safe(f.type_line)
    local fType = dashFix(fTypeRaw) ~= "" and dashFix(fTypeRaw) or typeLine

    if cmc ~= "" then
      return fName .. "\n" .. fType .. " " .. cmc .. "CMC"
    else
      return fName .. "\n" .. fType
    end
  end

  if cmc ~= "" then
    return name .. "\n" .. typeLine .. " " .. cmc .. "CMC"
  end
  return name .. "\n" .. typeLine
end

-- Description format: oracle + [b]P/T[/b] or loyalty
local function buildDescription(data)
  local function ptLine(obj)
    if obj and obj.power and obj.toughness then
      return "\n[b]" .. tostring(obj.power) .. "/" .. tostring(obj.toughness) .. "[/b]"
    elseif obj and obj.loyalty then
      return "\n[b]" .. tostring(obj.loyalty) .. "[/b]"
    end
    return ""
  end

  if data.card_faces and (not data.oracle_text) then
    local out = {}
    for _, f in ipairs(data.card_faces) do
      local ot = f.oracle_text or ""
      table.insert(out, ot .. ptLine(f))
    end
    return table.concat(out, "\n\n---\n\n")
  end

  return (data.oracle_text or "") .. ptLine(data)
end

local function getNextStackWorldPos()
  local base = self.getPosition()
  _stackIndex = _stackIndex + 1
  return {
    x = base.x + STACK_POS.x,
    y = base.y + BASE_LIFT + (_stackIndex * CARD_LIFT),
    z = base.z + STACK_POS.z
  }
end

local function makeCardCustom(deckId, faceURL, pos, nickname, description)
  return {
    Name = "CardCustom",
    Transform = {
      posX = pos.x, posY = pos.y, posZ = pos.z,
      rotX = 0, rotY = 180, rotZ = 0,
      scaleX = 1, scaleY = 1, scaleZ = 1
    },
    Nickname    = nickname or "",
    Description = description or "",
    CardID      = deckId * 100,
    CustomDeck  = {
      [tostring(deckId)] = {
        FaceURL = faceURL,
        BackURL = BACK_URL,
        NumWidth = 1,
        NumHeight = 1,
        BackIsHidden = true
      }
    }
  }
end

local function spawnCardFromJson(jsonText)
  local data = JSON.decode(jsonText)
  if not data then
    print("Scryfall: invalid JSON response.")
    return
  end
  if data.object == "error" then
    print("Scryfall error: " .. tostring(data.details or "Unknown error"))
    return
  end
  if data.object ~= "card" then
    print("Scryfall response was not a card object.")
    return
  end

  local face1 = pickFaceUrl(data)
  if not face1 then
    print("No image URL found for: " .. tostring(data.name or "unknown"))
    return
  end

  local deckId = _deckIdCounter
  _deckIdCounter = _deckIdCounter + 1

  local pos = getNextStackWorldPos()
  local nickname = buildNickname(data)
  local description = buildDescription(data)

  local cardObj = makeCardCustom(deckId, face1, pos, nickname, description)

  if USE_STATES_FOR_DFC and isDFC(data) then
    local face2 = pickFaceUrlAtIndex(data, 2)
    if face2 then
      local state2 = makeCardCustom(deckId, face2, pos, nickname, description)
      cardObj.States = {
        ["2"] = state2
      }
    else
      print("DFC detected but face 2 image missing for: " .. tostring(data.name or "unknown"))
    end
  end

  spawnObjectJSON({ json = JSON.encode(cardObj) })
end

---------------------------------------------------------------------------
-- Identity + Query
---------------------------------------------------------------------------
local function getIdentityStringOrNil()
  local id = ""
  if White then id = id .. "W" end
  if Blue  then id = id .. "U" end
  if Black then id = id .. "B" end
  if Red   then id = id .. "R" end
  if Green then id = id .. "G" end
  if id == "" then return nil end
  return id
end

local function buildRandomQuery()
  local q = "game:paper -is:digital -is:funny"
  local id = getIdentityStringOrNil()
  if id then
    q = q .. " id:" .. id
  end
  return q
end

local function fetchAndSpawnOneRandom()
  local q = buildRandomQuery()
  local url = SCRY_BASE .. "/cards/random?q=" .. urlEncode(q)

  queueRequest(url, function(ok, body)
    if ok then
      spawnCardFromJson(body)
    else
      print("Random fetch failed: " .. tostring(body))
    end
  end)
end

---------------------------------------------------------------------------
-- Button utilities
---------------------------------------------------------------------------
local function getButtonIndexByClickFunction(fn)
  local btns = self.getButtons()
  if not btns then return nil end
  for _, b in ipairs(btns) do
    if b.click_function == fn then
      return b.index
    end
  end
  return nil
end

local function setToggleColor(fn, isOn, onColor)
  local idx = getButtonIndexByClickFunction(fn)
  if idx then
    self.editButton({ index = idx, color = (isOn and onColor or Color.Grey) })
  end
end

---------------------------------------------------------------------------
-- Toggle functions (must be global for TTS buttons)
---------------------------------------------------------------------------
function tW()
  White = not White
  setToggleColor("tW", White, Color.White)
end

function tU()
  Blue = not Blue
  setToggleColor("tU", Blue, Color.Blue)
end

function tB()
  Black = not Black
  setToggleColor("tB", Black, Color.Black)
end

function tR()
  Red = not Red
  setToggleColor("tR", Red, Color.Red)
end

function tG()
  Green = not Green
  setToggleColor("tG", Green, Color.Green)
end

---------------------------------------------------------------------------
-- Main action
---------------------------------------------------------------------------
function spawn14RandomCards()
  forceUnlockIfTimedOut()
  if _busy then return end

  _busy = true
  _spawnEndsAt = os.time() + SPAWN_TIMEOUT_SECONDS

  -- reset pile height each time so you always get a single pile
  _stackIndex = 0

  -- Optional: reset deck id counter so every run starts clean
  _deckIdCounter = 1

  for i = 1, 14 do
    schedule(fetchAndSpawnOneRandom, (i - 1) * 0.01)
  end

  -- unlock after expected queue time + buffer
  schedule(function()
    _busy = false
    _spawnEndsAt = 0
  end, (14 * MIN_DELAY) + 2)
end
_G["spawn14RandomCards"] = spawn14RandomCards

---------------------------------------------------------------------------
-- UI
---------------------------------------------------------------------------
local function createColorToggleButtons()
  self.createButton({click_function="tW", function_owner=self, label="W", position={-1.10, BTN_Y, -0.75}, rotation=BTN_ROT, width=300, height=200, font_size=150, color=Color.Grey})
  self.createButton({click_function="tU", function_owner=self, label="U", position={-0.55, BTN_Y, -0.75}, rotation=BTN_ROT, width=300, height=200, font_size=150, color=Color.Grey})
  self.createButton({click_function="tB", function_owner=self, label="B", position={ 0.00, BTN_Y, -0.75}, rotation=BTN_ROT, width=300, height=200, font_size=150, color=Color.Grey})
  self.createButton({click_function="tG", function_owner=self, label="G", position={ 0.55, BTN_Y, -0.75}, rotation=BTN_ROT, width=300, height=200, font_size=150, color=Color.Grey})
  self.createButton({click_function="tR", function_owner=self, label="R", position={ 1.10, BTN_Y, -0.75}, rotation=BTN_ROT, width=300, height=200, font_size=150, color=Color.Grey})
end

function onLoad()
  math.randomseed(os.time())

  createColorToggleButtons()

  self.createButton({
    click_function = "spawn14RandomCards",
    function_owner = self,
    label          = "Spawn Color Booster Pack",
    position       = {0, BTN_Y, 0.0},
    rotation       = BTN_ROT,
    width          = 1900,
    height         = 420,
    font_size      = 150,
    color          = Color.Grey,
    tooltip        = "Toggle W/U/B/R/G, then spawn 14 random paper, non-funny cards. (All stack into one pile.)"
  })
end
